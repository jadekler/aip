---
aip:
  id: 194
  state: reviewing
  created: 2019-08-16
permalink: /194
redirect_from:
  - /0194
---


# Retrying for client libraries

Disclaimer: this document often uses the term "CRUD". This acronym stands for
Create, Read (Get, List, etc.), Update, Delete. The document uses a narrow
definition of CRUD in which CRUD refers to basic operations - creating an
entire resource, reading an entire resource (or set of resources), updating
an entire resource, and deleting an entire resource. This document does not
consider partial operations: incrementing a part of a resource, for example,
is not considered a CRUD operation.

Most requests can either be categorized as **retryable**, **transactional**, or
**non-retryable**.

**Retryable** requests are requests in which repeated runs would not cause
unintended state changes. Most CRUD RPCs which take a unique identifier are
considered retryable (see more below in "Idempotency and pragmaticism").


**Transactional** requests are requests which are part of a transactions. These
requests should not be retried individually, but instead should have user-level
retry logic that retries the entire transaction block from the start.

**Non-retryable** requests should never be retried.

## Codes that generally should be retried

### Unary requests

- `INTERNAL`: This generally means that some internal part of the system has
failed. These are retryable under the expectation that the system will recover
from failures.
- `UNAVAILABLE`: These codes generally result from network hiccups, and are
generally transient. They are retryable under the expectation that the
connection will become available (soon).

### Streaming requests

Streaming requests can be categorized as **server streaming**,
**client streaming**, and **bidirectional streaming**.


**Server streaming** typically involves no data sent from the client, meaning
that it generally is an idempotent `GET`. That makes it safe to retry `INTERNAL`
and `UNAVAILABLE`.

**Client streaming** request retryability is highly dependent on the type of
data being streamed.

**Bidirectional streaming** request retryability is highly dependent on the type
of data being streamed.


## Codes that should never be retried

- `OK`: The request succeeded.
- `CANCELLED`: A user can cancel a request, which we should honour.

- `DEADLINE_EXCEEDED`: A user can set a deadline, which we should honour.
- `INVALID_ARGUMENT`: Retrying a request with an invalid argument will never
  succeed.
- `DATA_LOSS`: This is an unrecoverable error and should immediately be surfaced
  to the user.

## Codes that generally should not be retried

Some codes can be retried if a system is designed without
synchronization/communication between various components. For example, a system
in which a read should hang forever until a resource is created.

However, these are not the types of systems we generally encourage, and we should
not retry these types of errors. It's generally better to design a system built
on signals and current state instead of expected behavior. The errors that fall
into this category are:

- `RESOURCE_EXHAUSTED`: This may be a signal that the user's quota is exhausted.
  Retries therefore may not be expected to work for several hours; meanwhile the
  retries might have billing implications. If `RESOURCE_EXHAUSTED` is used for
  other reasons than quota and the expected time for the resource to become
  available is much shorter, it may be retryable.
- `NOT_FOUND`: The resource might be created in the future.
- `ALREADY_EXISTS`: The resource might be deleted in the future.
- `PERMISSION_DENIED`: The user might be authenticated in the future.
- `FAILED_PRECONDITION`: The system state might change in the future.
- `OUT_OF_RANGE`: The range might be extended in the future.
- `UNIMPLEMENTED`: The RPC might be implemented in the future.
- `UNKNOWN`: `UNKNOWN` and `INTERNAL` are both "kitchen sink" errors - they are
  errors that might be generated from a wide breadth of causes. Generally,
  known services within the system should generate `INTERNAL` errors when the
  error doesn't fit any other code. `UNKNOWN` errors should be reserved for truly
  unknown-to-the-system errors, and therefore should be immediately surfaced to
  the user.

------------------

## Idempotency and pragmaticism

A common concern with retrying Create and Delete operations is that these are
non-idempotent. The functional concern can be summarized with this example:

```
Get("Foo")
> NOT_FOUND
Create("Foo") // Let's work under the assumption that we should retry this for now.
// ----> UNAVAILABLE
// ----> Create("Foo") # retry #1
// ----> UNAVAILABLE   # actually, the request succeeded, but the connection died during the response
// ----> Create("Foo") # retry #2
// ----> ALREADY_EXISTS
> ALREADY_EXISTS
```

Here, an unexpected result - `ALREADY_EXISTS` - is returned from a Create. We
know the resource didn't exist before the call was initiated, so the user might
wonder: how did we receive this result?

The definition of idempotency is unfortunately vague in this regard. Idempotent
is defined as,


> denoting an element of a set which is unchanged in value when multiplied or
> otherwise operated on by itself.

One interpretation of this definition is that an operation is idempotent if
repeating the operation results in the same _response_.

Another intepretation of this definition is that an operation is idempotent if
repeating the operation results in the same _state_ (or, value).

The former definition allows for retrying `READ` and `UPDATE` requests, since
repeated runs in isolation always result in the same state and response code.
However, this definition precludes retrying `CREATE` calls, since
`ALREADY_EXISTS` may be returned unexpectedly (as in the above example). It also
precludes retrying `DELETE` calls, since `NOT_FOUND` might be returned.

The latter defintion allows for retrying all CRUD operations, since it's only
concerned with state, and in all CRUD operations repeating an operation always
results in the same state.

This document uses the latter definition, which allows for retrying all
CRUD operations. The reason for this is that there's much more value for users
to retry all operations, with little downside.

Consider the downside to retrying the `CREATE` and `DELETE` operations. For
users it generally just results in an extra code check:

```
resp, err := client.Create("Foo)
if err != nil {
  if status.Convert(err).Code() == codes.ALREADY_EXISTS { // <- extra code check
    // It already exists.
    resp = client.Get("Foo")
  } else {
    // An actual error.
    panic(err)
  }
}
_ = resp // TODO: Use resp.
```

The above code is quite natural and exists in many codebases already: it is the
easy answer to asynchrony within a system, and a cheaper/more performant way
of writing code that doesn't know about state (the alternative is to always
perform a `READ` before a `CREATE`/`DELETE`, which is superfluous).

In comparison to the relatively small downside, there is a large advantage.
Users will _almost always_ retry `INTERNAL` and `UNAVAILABLE`. By building it
into a client library instead, users are saved from implementing retry loops,
deadlines, exponential backoff, and jitter.

Finally, consider that most users _will have to write the if statement either
way_. After all, a user who implements retry logic themselves will _still_ run
into the same problem (and solution) described above.

#### Absolute correctness

There is an argument that some user might need to be absolutely sure of the
state of a system before retrying a request. Such a user is an argument in
favour of the retry-only-`GET` approach. However, this set of users likely has
very niche requirements, and is dwarfed by the set of users for whom retrying
is advantageous.

A simple answer exists to support this set of users: provide an opt-out for
retries. This approach fits the generally-accepted goal of client libraries
striving for setting good defaults with opt-outs for the minority of users.

## The async fallacy

Another argument against retrying `CREATE` and `DELETE` that sometimes pops up
is as such:

```
Thread1: Get("Foo")
Thread1: > NOT_FOUND
Thread2: Get("Foo")
Thread2: > NOT_FOUND
Thread1: Create("Foo") // Let's work under the assumption that we should retry this for now.
Thread1: // ----> UNAVAILABLE
Thread2: Create("Foo")
Thread2: // ----> OK
Thread1: // ----> Create("Foo") # retry #1
Thread1: // ----> ALREADY_EXISTS
Thread1: > ALREADY_EXISTS
```

Here, an asynchronous system has two threads that convince themselves that
"Foo" does not exist, and then try to create it. Because Thread1 retried the
first failed Create request, it unexpectedly returned `ALREADY_EXISTS`.

However, it is easy to see that _one of_ these requests would have to receive
`ALREADY_EXISTS`, even if no retrying happening.

There are numerous solutions to this:

- Run these requests in a read-write transaction, ensuring atomicity.
- Make the system synchronous.
- Add a piece of code that considers `ALREADY_EXISTS` a success case (as above
  described in "Idempotency and pragmaticism").

Either way, the problem here is not the retrying, and the solution is not to
retry less operations.
